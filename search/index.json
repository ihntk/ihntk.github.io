[{"content":"Keepassxc запустити кпсх, налаштування - загальне автоматично запускати + при закритті згортати до системного лотка, сполучення з переглядачем - вибрати браузер\nекспорт з хрома Налаштування \u0026gt; Паролі меню3точки експорт вказуємо назву сховища, погоджуємося з налаштуваннями, потім задаємо пароль\nKwallet Kwallet Wiki\nЩоб забезпечити автоматичний вхід в keepassxc за допомогою kwallet, потрібно вручну додати запис в торбинку: Відкриваємо kwalletManager, в каталозі Passwords в розділі Паролі пкм-створити вводимо назву запису kpasxс, в правому полі натискаємо \u0026ldquo;показати вміст\u0026rdquo; і вводимо пароль, натискаємо зберегти. Потім створюємо скрипт автозапуску:\nsleep 9 kwallet-query -f Passwords -r kpasxс kdewallet | keepassxc --pw-stdin path/to/db.kdbx команда прочитає запис kpasxс з каталога Passwords торбинки kdewallet і передасть в keepassxc, sleep потрібен, щоб kwalletd встиг запуститися\nЯкщо в торбинки такий же пароль як і в користувача, то при вході в систему за допомогою PAM здійсниться автоматичний вхід в торбинку. Потрібно, також, перевірити налаштування для PAM\n","date":"2021-12-09","permalink":"https://ihntk.github.io/post/passman/","tags":["passwd"],"title":"Зберігання паролів"},{"content":"Установка rTorrent # pacman -S rtorrent Налаштування rTorrent В даному прикладі використовується настройка для користувача sdbox\nРобочі каталоги rTorrent $ mkdir -p ~/.local/share/rtorrent $ mkdir -p ~/Downloads/tor/{music,packages/win,videos/{films,mult,series}} $ mkdir -p /home/sdbox/{Music,packages/win,Videos/{Films,Cartoons,Series}} файл конфігурації nvim .rtorrent.rc\nsession.path.set = /home/sdbox/.local/share/rtorrent network.scgi.open_local = /home/sdbox/.local/share/rtorrent/rtorrent.sock execute.nothrow = chmod,770,/home/sdbox/.local/share/rtorrent/rtorrent.sock schedule2 = watch_directory_1,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/music/*.torrent,d.directory.set=/home/sdbox/Music\u0026quot; schedule2 = watch_directory_2,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/packages/*.torrent,d.directory.set=/home/sdbox/packages\u0026quot; schedule2 = watch_directory_3,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/packages/win*.torrent,d.directory.set=/home/sdbox/packages/win\u0026quot; schedule2 = watch_directory_4,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/videos/films/*.torrent,d.directory.set=/home/sdbox/Videos/Films\u0026quot; schedule2 = watch_directory_5,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/videos/mult/*.torrent,d.directory.set=/home/sdbox/Videos/Cartoons\u0026quot; schedule2 = watch_directory_6,10,10,\u0026quot;load.start=/home/sdbox/Downloads/tor/videos/series/*.torrent,d.directory.set=/home/sdbox/Videos/Series\u0026quot; schedule2 = low_diskspace,5,60,close_low_diskspace=1000M pieces.hash.on_completion.set = yes Автозапуск rTorrent Users service Запуститься лише після того як користувач увійде в систему. Підходить для медіацетра Kodi\npath ~/.config/systemd/user/rtorrent.service\n[Unit] Description=rtorrent After=network.target [Service] Type=forking ExecStartPre=/usr/bin/bash -c \u0026quot;if test -e ~/.local/share/rtorrent/rtorrent.lock \u0026amp;\u0026amp; test -z `pidof rtorrent`; then rm -f ~/.local/share/rtorrent/rtorrent.lock; fi\u0026quot; ExecStart=/usr/bin/tmux -L rt new-session -s rt -n rtorrent -d rtorrent ExecStop=/usr/bin/bash -c \u0026quot;/usr/bin/tmux -L rt send-keys -t rt:rtorrent.0 C-q; while pidof rtorrent \u0026gt; /dev/null; do echo stopping rtorrent...; sleep 1; done\u0026quot; Restart=on-failure [Install] WantedBy=default.target Запуск systemctl --user enable --now rtorrent\nSystem service Цей варіант підходить для безголового сервера\npath /etc/systemd/system/rtorrent@.service\n[Unit] Description=rTorrent Daemon for %i After=network.target [Service] Type=simple User=%i WorkingDirectory=/home/%i ExecStartPre=/bin/rm -f /home/%i/.local/share/rtorrent/rtorrent.lock ExecStart=/usr/bin/rtorrent -o system.daemon.set=true Restart=on-failure RestartSec=3 [Install] WantedBy=multi-user.target Запуск systemctl enable --now rtorrent@user\nУстановка Flood Arch $ yay -S flood-git Користувач flood створиться під час установки пакета автоматично В файлі /etc/flood/config.js потрібно встановити значення \u0026lsquo;0.0.0.0\u0026rsquo;, щоб мати доступ до сервера з інших компʼютерів\nfloodServerHost: '0.0.0.0', flood service також установлюється з пакетом Запуск systemctl enable --now flood\nArmbian Flood Wiki\nВстановлюємо nodejs\ncurl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash - sudo apt install -y nodejs Далі я розпакував flood з пакету зібраного для Arch в корінь /, щоб не тягти в залежностях npm\nДля запуску замінив service /lib/systemd/system/flood@.service\n[Unit] Description=Flood service for %I After=network.target [Service] User=%I Group=%I Type=simple KillMode=process ExecStart=/usr/bin/env flood --host=\u0026quot;0.0.0.0\u0026quot; Restart=on-failure RestartSec=3 [Install] WantedBy=multi-user.target Запуск systemctl enable --now flood@user\nПосилання https://rawsec.ml/en/archlinux-install-rtorrent-flood-sftp/ https://github.com/Flood-UI/flood/wiki/Install-flood-with-a-service-account\n","date":"2021-09-10","permalink":"https://ihntk.github.io/post/rtorrent/","tags":["torrent"],"title":"Rtorrent і Flood"},{"content":"Налаштування віртуальної машини В налаштуваннях vbox’а додаємо мережевий адаптер \u0026lsquo;vboxnet0\u0026rsquo; в розділі мережі хосту. В налаштуваннях віртуальної машини встановлюємо перший адаптер в NAT - для доступу в світ, другий адаптер - головний адаптер -\u0026gt; vboxnet0 для доступу з хоста в гість, третій - внутріштя мережа -\u0026gt; intnet для доступу до інших віртуальних машин\nв гості налаштовуємо /etc/rc.d/rc.inet1.conf:\neth0 -\u0026gt; dhcp\neth1 -\u0026gt; address 192.168.56.10 netmask 255.255.255.0 # IP scope 192.168.56.* was set in VistualBox Network Settings into interface vboxnet0\nsudo rm /etc/udev/rules.d/70-persistent-net.rules reboot Налаштування git створюємо групу git, користувача git:git, додаємо потрібних корисувачів до групи git, створюємо каталог /opt/git з відповідними правами\nНалаштування apache див Apache HTTP Server - ArchWiki\n/etc/httpd/httpd.conf - файл конфігурації\n/srv/httpd/htdocs - DocumentRoot\n/etc/httpd/extra/httpd-vhosts.conf - файл конфігурації віртуальних хостів\nВіртуальні хости в http.conf потрібно розкоментувати стрічку Virtual hosts Include /etc/httpd/extra/httpd-vhosts.conf і налаштувати хости в /etc/httpd/extra/httpd-vhosts.conf Для можливості керування кожним хостом окремо можна створити каталог /etc/httpd/vhosts і в ньому розмістити файли конфігурації для кожного хоста. Потім внести їх до http.conf #Enabled Vhosts: Include conf/vhosts/domainname1.dom Include conf/vhosts/domainname2.dom \u0026hellip; і при необхідності включати і виключати їх\nНалаштування nginx nginx - ArchWiki\nВ роутері налаштовуємо DNS для потрібного сайту\nВ каталозі /etc/nginx/sites-available створюємо файл sitename.dom і заповнюємо його:\nserver { listen 80; listen [::]:80; root /var/www/sitename.dom; index index.html; server_name sitename.dom; location / { try_files $uri $uri/ =404; } } В /var/www/sitename.dom/ розміщуємо сайт з контентом\nЩоб на веб-сторінці відобразити файлову систему, потрібно в розділі location вказати каталог, який буде відображатися (/, /some/dir) і вказати autoindex on:\nserver { listen 80; listen [::]:80; root /var/www/site_with_fs.dom; index index.html; server_name site_with_fs.dom; location / { autoindex on; } } SSHFS SSHFS - ArchWiki\nНа сервері і клієнті повинен бути встановлений openssh\nна клієнті: встановлюємо pacman -S sshfs\nгенеруємо ключ для користувача $ ssh-keygen і відправляємо його на сервер\n$ ssh-copy-id server.dom\nповторюємо для суперрута # ssh-keygen і # ssh-copy-id user@server.dom\nПідключаємо вручну: sshfs [user@]server.dom:[dir] mountpoint [options] Підключення автоматично за вимогою: до /etc/fstab додаємо стрічку (myuser замінити на нік свого користувача)\nmyuser@host:/remote/folder /mount/point fuse.sshfs noauto,x-systemd.automount,_netdev,users,idmap=user,IdentityFile=/home/myuser/.ssh/id_rsa,allow_other,reconnect 0 0 можна спробувати додати до опцій монтування параметр x-systemd.idle-timeout=1min, який відмонтовує фс через 1хв простою (не знаю, чи потрібно це тут, підглянув у вікі про nfs)\n","date":"2021-09-10","permalink":"https://ihntk.github.io/post/server/","tags":["linux","nginx","ssh"],"title":"Налаштування сервера"},{"content":"З сайту Ubuntu скачуємо mini.iso, установлюємо мінімальну систему, завантажуємося в неї.\nsudo apt install --no-install-recommends software-properties-common -y sudo add-apt-repository ppa:team-xbmc/ppa -y sudo apt update sudo apt install --no-install-recommends xserver-xorg-core -y # Basic Xorg libraries, utilities sudo apt install --no-install-recommends xserver-xorg-input-all -y # Provides input driver for devices like keyboard, touchpad sudo apt install --no-install-recommends xserver-xorg-video-fbdev -y # Xorg display driver #sudo apt install --no-install-recommends xserver-xorg-video-(driver, can be intel, nouveau, vmware or ati) # Free and open-sourced video drivers sudo apt install --no-install-recommends xinit -y # X session starting tools sudo apt install slim pulseaudio kodi -y pactl set-sink-mute 0 false ; pactl set-sink-volume 0 0x10000 ln -s ~/.xinitrc ~/.xsession sudo nano /etc/slim.conf ","date":"2021-08-22","permalink":"https://ihntk.github.io/post/ubuntu-install/","tags":["linux","kodi"],"title":"Мінімальна установка Ubuntu і Kodi"},{"content":"Sway https://github.com/swaywm/sway/wiki\nНалаштування графічних тулкітів GTK3 скрипт для імпорту налаштувань з gtk3/settings.ini в gsettings - import-gsettings\n#!/bin/sh # usage: import-gsettings config=\u0026quot;${XDG_CONFIG_HOME:-$HOME/.config}/gtk-3.0/settings.ini\u0026quot; if [ ! -f \u0026quot;$config\u0026quot; ]; then exit 1; fi gnome_schema=\u0026quot;org.gnome.desktop.interface\u0026quot; gtk_theme=\u0026quot;$(grep 'gtk-theme-name' \u0026quot;$config\u0026quot; | cut -d'=' -f2)\u0026quot; icon_theme=\u0026quot;$(grep 'gtk-icon-theme-name' \u0026quot;$config\u0026quot; | cut -d'=' -f2)\u0026quot; cursor_theme=\u0026quot;$(grep 'gtk-cursor-theme-name' \u0026quot;$config\u0026quot; | cut -d'=' -f2)\u0026quot; font_name=\u0026quot;$(grep 'gtk-font-name' \u0026quot;$config\u0026quot; | cut -d'=' -f2)\u0026quot; decor_layout=\u0026quot;$(grep 'gtk-decoration-layout' \u0026quot;$config\u0026quot; | cut -d'=' -f2)\u0026quot; gsettings set \u0026quot;$gnome_schema\u0026quot; gtk-theme \u0026quot;$gtk_theme\u0026quot; gsettings set \u0026quot;$gnome_schema\u0026quot; icon-theme \u0026quot;$icon_theme\u0026quot; gsettings set \u0026quot;$gnome_schema\u0026quot; cursor-theme \u0026quot;$cursor_theme\u0026quot; gsettings set \u0026quot;$gnome_schema\u0026quot; font-name \u0026quot;$font_name\u0026quot; gsettings set org.gnome.desktop.wm.preferences button-layout \u0026quot;$decor_layout\u0026quot; більше про налаштування GTK тут\nQT QT_QPA_PLATFORM=wayland - помойму необовʼязковий QT_WAYLAND_DISABLE_WINDOWDECORATION=\u0026quot;1\u0026quot; - відключає client-side decorations\n","date":"2021-08-21","permalink":"https://ihntk.github.io/post/wayland/","tags":["linux"],"title":"Wayland"},{"content":"Різне Nvidia GeForce 8600 - для ядра lts потрібно встановити пакет nvidia-340xx-lts-dkms з AUR\nBluetooth В arch потрібно втсаровити пакет pulseaudio-bluetooth і якийсь фронтенд для блютуса перезавантажити пульсаудіо, потім можна підключати пристрій\nЗатримка визначаємо назву карти пристрою в пульсі\n$ pacmd list-sinks | egrep -o 'bluez_card[^\u0026gt;]*' підставляємо сюди:\n$ pactl set-port-latency-offset \u0026lt;bluez_card\u0026gt; headset-output 125000 порти можуть бути speaker-output, headset-output (підхоплюється tab\u0026rsquo;ом)\nзатримка в мікросекундах\nBattary status upower -i $(upower -e | grep BAT) | grep -E \u0026quot;state|to\\ full|to\\ empty|percentage\u0026quot; Brightness echo 50 \u0026gt; /sys/class/backlight/intel_backlight/brightness ","date":"2021-08-21","permalink":"https://ihntk.github.io/post/archlinux/","tags":["linux"],"title":"Archlinux"},{"content":"Arch wiki\nУстановка в UEFI Потрібно установити пакети grub і efibootmgr.\nЯкщо OS завантажена в режимі UEFI, системний завантажувальний розділ EFI змонтований в /boot/efi, то для установки завантажувача потрібно виконати команду\n# grub-install Програма згенерує EFI-додаток, скопіює його в /boot/efi/EFI/arch/grubx64.efi, файли завантажувача запише в /boot/grub/, і спробує за допомогою efibootmgr записати в змінну UEFI завантажувальний запис з посиланням на \\EFI\\arch\\grubx64.efi\nМожливі параметри --boot-directory=/path/to/boot - вказує шлях в якому буде розміщений каталог grub/ і, якщо окремо не вказано, каталог монтування завантажувального роздулу EFI (за умовчанням /boot) --efi-directory=/path/to/efi - вказує каталог монтування завантажувального роздулу EFI --bootloader-id=arch - вказує каталог,в який запишеться efi-додаток (\\EFI\\arch\\grubx64.efi) --removable - efi-додаток запишеться в \\EFI\\BOOT\\ і efibootmgr не зробить запис до змінної UEFI, потрібно для флешок Якщо система завантажена в legacy BIOS, потрібно явно вказати, що grub повинен створити завантажувач для UEFI за допомогою параметра target\n--target=x86_64-efi при цьому efibootmgr також не викликається\nУстановка в legacy BIOS Grub завантажується в 2 етапи: Спочатку зчитується boot.img з першого завантажувального блоку, який завантажує core.img з додаткового розділу чи спеціально відведеного місця.\nЯкщо носій розмічено в gpt, потрібно створити розділ типу BIOS boot partition розміром 1Mb. Якщо - в mbr потрібно забезпечити пусте місце розміром 1Mb між першим завантажувальним блоком і першим розділом (fdisk робить це автоматично)\nЗ системи завантаженої в UEFI вказуємо target\n# grub-install --target=i386-pc /dev/sdw Установка на флешку для UEFI і для legacy Флешку розмічаємо в gpt, створюємо розділ ESP, розділ BIOS boot partition, і основний розділ для OS. Форматуємо ESP в vfat, основний розділ - ext4 чи f2fs, Bios boot - не форматуємо.\nМонтуємо основний розділ в /mnt/os, монтуємо ESP в /mnt/esp, розпаковуємо образ, переносимо каталог EFI в /mnt/esp і виконуємо команди:\ngrub-install --target=i386-pc --boot-directory=/mnt/os/arch/boot /dev/sdw grub-install --target=x86_64-efi --boot-directory=/mnt/os/arch/boot --efi-directory=/mnt/esp --removable Якщо ESP змонтувати в /mnt/os/arch/boot/efi, то параметр efi-directory можна не вказувати\nНалаштування Налаштування конфігуратора знаходяться в файлі /etc/default/grub і в каталозі /etc/grub.d/. Головний файл конфігурації розміщений в /boot/grub/grub.cfg. Для автоматичного генерування цього файлу потрібно виконати команду\n# grub-mkconfig -o /boot/grub/grub.cfg Шоб конфігуратор визначив OS відмінні від linux потрібно встановити os-prober\n","date":"2021-08-21","permalink":"https://ihntk.github.io/post/grub/","tags":["linux","boot"],"title":"Grub"},{"content":"Скачуємо список з fs.to export LANG=«uk_UA.UTF8» (export LANG=«ru_RU.UTF8») wget -i /path/to/url-file --restrict-file-names=unix,nocontrol в результаті маємо скачані файли в назвах яких замість пробілів плюсики :)\nСкачуємо сайт wget -r -k -p -E -nc https://git-scm.com/book/uk/v2 -np --restrict-file-names=unix,nocontrol Параметри wget -i - список url\n-r - рекурсивно\n-k - заміна абсолютних зсилок на відносні\n-p - завантажити додаткові файли (зображення, css etc.)\n-l - кількість вкладень (цифра)\n-E - додає .html до скачаних файлів\n-nc - не заміняти існуючі (після переривання)\n-np - тільки підкаталоги\n--restrict-file-names=unix,nocontrol - перетворення регулярних символів в url\n","date":"2021-08-21","permalink":"https://ihntk.github.io/post/wget/","tags":["download"],"title":"Wget"},{"content":"Створення сайта hugo new site (path/to/)siteName створює сайт (у вказаному шляху). Потрібно скопіювати тему в каталог themes/ і додати в файл конфіга:\necho 'theme = \u0026quot;themeName\u0026quot;' \u0026gt;\u0026gt; config.toml Щоб створити сторінку:\nhugo new post/my-post.md створює сторінку в каталозі content/post. В title сторінки підставляє назву файла, замінюючи знаки - на пробіли\nЗбірка і публікація hugo команда збирає сайт і розміщує його в каталозі public/\nфлаги:\n-D\t--buildDrafts\t(draft: true) -E\t--buildExpired\t(expirydate) -F\t--buildFuture\t(publishdate) перед кожною збіркою потрібно видалими public/ , інакше це може призвести до помилок\nРозробка hugo server запускає сервер http://localhost:1313/, який в реальному часі оновлює всі зміни, що відбуваються в наступних місцях:\nstatic/* content/* data/* i18n/* layouts/* themes/\u0026lt;CURRENT-THEME\u0026gt;/* config щоб запустити сервер без оновлення в реальному часі використувуюють наступні команди:\nhugo server --watch=false або\nhugo server --disableLiveReload або вказати в файлі конфіга:\ndisableLiveReload = true ","date":"2020-08-20","permalink":"https://ihntk.github.io/post/hugo-tutorial/","tags":["website"],"title":"Коротка інструкція з Hugo"},{"content":"Заходимо в Project structure \u0026gt; Artifacts. Якщо є якийсь артифакт, видаляємо його(-) і натикаємо + \u0026gt; JAR \u0026gt; From modules with dependencies, вибираємо головний клас. Якщо до цього був якийсь маніфест, бажано його видалити, щоб ідея не лаялась \u0026gt; OK\nМеню Build \u0026gt; Build Artifacts\u0026hellip; Вибираємо створений артифакт. Забираємо файл jar в каталозі out\nТаким чином можна зібрати програму з усіма бібліотеками, включаючи javaFX, інтерфейс якої можна запустити з консолі через прапорець -g. Напряму з вінди з 14 джавою і javaFX зібрати javaFX артефакт не вдалося, так само як і за допомогою maven\nОстанні спостереження В Project structure \u0026gt; Project вибрана SDK 11(zulu)\t- впливає на те яку jvm використовуватиме maven - на 18 не хотів збирати \u0026gt; Libraries натискаємо + додаємо java бібліотеку - вказуємо шлях де розміщена javafx (/lib/jvm/java-19-openjdk/lib)\t- після цього зникають всі помилки повʼязані з тим, що компілятор на розуміє бібліотек javafx \u0026gt; Platform Settins \u0026gt; SDKs є 11 і 19, вибрана 19 (не знаю як потрібно правильно) В Run/Debug Configuration вибрана 11 sdk\n","date":"2020-08-20","permalink":"https://ihntk.github.io/post/create-java-artifact/","tags":["java","dev"],"title":"Cтворення артифакта Java"},{"content":"Для маніпуляції даними, git має в своєму розпорядження три сутності: HEAD, індекс і робочий каталог.\nHEAD - вказівник на останній коміт, що містить зміни (список і diff файлів).\nіндекс - пропозиція наступного коміту, містить зміни, які можна закомітити (заповнюється змінами даних з робочого каталогу за допомогою команди add).\nРобочий каталог - каталог файлової системи з поточними файлами.\nЯкщо всі три сутності містять однакові дані, команда git status поверне nothing to commit, working tree clean.Якщо ми зробили зміни у робочому каталозі, командою git add ми додамо ці зміни до індексу (індексуємо зміни).Потім за допомогою команди git commit ми копіюємо ці зміни (список файлів та їх diff\u0026rsquo;и) в новий коміт, та присвоюємо його вказівнику HEAD.\nHEAD, зазвичай, повинен вказувати на вказівник гілки (branch), який, в свою чергу, вказує на останній коміт HEAD:=master:=last_commit.\nГілка являє собою ланцюжок комітів, насправді вона вказує на останній коміт ланцюжка. За допомогою команди git chechout ми присвоюємо вказівнику HEAD будь який коміт, зміни з якого заповнюються до індексу. З індексу до робочого каталогу копіюються файли. Якщо HEAD не вказує на гілку, він знаходиться у відірваному стані і git status поверне HEAD detached at \u0026lt;some commit\u0026gt;. У такому випадку потрібно, або повернутися до якоїсь гілки, або в поточному місці створити нову. Без гілки можна легко втратити дані.\nПроіндексовані зміни називають staged changes, неіндексовані - unstaged changes\nHEAD^ (HEAD~1) - перший коміт перед HEAD\n","date":"2019-10-16","permalink":"https://ihntk.github.io/post/git/","tags":["git","dev"],"title":"Замітки про Git"},{"content":"Спроба запустити блог на Jekyll\nУстановка Jekyll Для запуску і налаштування сайту на компʼютері потрібно встановити Jekyll. Для цього в терміналі даємо команду:\n# gem install jekyll Потім скачуємо шаблон і наповнюємо його. Для запуску сервера Jekyll потрібно зайти в корінь сайту і дати команду:\n$ jekyll serve Для шаблона White Paper, Jekyll видав якусь ругань відносно bundlerʼа. Довелося ще дещо зробити:\n# gem install bundler $ bundle install $ bundle exec jekyll serve Як виявилося це все описано в README\nПісля запуску сервера, в браузері переходимо на сайт за адресою:\nhttp://localhost:4000/ Наповнення сайту Щоб додати пост, ідемо до каталога _posts і створюємо фойл за типом:\nYYYY-MM-DD-post-name.md чи YYYY-MM-DD-post-name.html і наповнюємо його.\n","date":"2017-08-30","permalink":"https://ihntk.github.io/post/install-jakyll-and-creating-site/","tags":["website"],"title":"Створення сайту на Jekyll"}]